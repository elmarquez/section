<!DOCTYPE html>
<html>
<head lang="en">
    <meta charset="UTF-8">
    <title></title>
    <style type="text/css">
        #viewport {
            border: 1px solid gray;
            height: 640px;
            width: 800px;
        }
    </style>
    <link type="text/css" href="../lib/OpenJSCAD.org/openjscad.css">
    <script type="text/javascript" src="../lib/threejs/build/three.js"></script>
    <script type="text/javascript" src="OrbitControls.js"></script>
    <script type="text/javascript" src="../lib/OpenJSCAD.org/csg.js"></script>
    <script type="text/javascript" src="../lib/OpenJSCAD.org/openjscad.js"></script>
</head>
<body>
<h1>Section</h1>

<div id="viewport" style="clear:both"></div>
<button onclick="explode()">Explode</button>
<button onclick="collapse()">Collapse</button>
<script type="text/javascript">
    // Set up the scene, camera, and renderer as global variables.
    var scene, camera, renderer, viewport;
    var HEIGHT = 640, WIDTH = 800;
    // define the model to be build
    var model = [
        [
            {
                name: "brick",
                height: 76,
                width: 230,
                thickness: 110,
                color: 0xffff00,
                material: {
                    texture: 'brick-standard-red.jpg'
                },
                transparency: 0.6,
                type: "unit",
                offset: [0, 10, 10, 0, 5, 0] // top, left, bottom, right, front, back
            },
            {
                name: "mortar",
                thickness: 10,
                color: 0xaaaaaa,
                offset: []
            }
        ],
        {
            name: "air gap",
            thickness: 25,
            color: 0xefefef,
            opacity: 0.1
        },
        {
            name: "building wrap",
            thickness: 1,
            color: 0x888888,
            material: {
                texture: 'tyvek.jpg'
            }
        },
        {
            name: "sheathing",
            thickness: 14,
            color: 0x0000ff,
            material: {
                texture: 'plywood-douglas-fir.jpg'
            }
        },
        [
            {
                name: "wood stud",
                width: 38,
                thickness: 89,
                color: 0xcccccc,
                material: {
                    texture: 'lumber-douglas-fir.jpg'
                }
            },
            {
                name: "insulation",
                color: 0xcccccc,
                material: {
                    texture: 'insulation-batt-pink.jpg'
                }
            }
        ],
        {
            name: "plasterboard",
            thickness: 10,
            color: 0x0000ff,
            material: {
                texture: 'plasterboard.jpg'
            }
        }
    ];

    // Sets up the scene.
    function init() {
        // Create the scene and set the scene size.
        scene = new THREE.Scene();
        viewport = document.getElementById("viewport");

        // Create a renderer and add it to the DOM.
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(WIDTH, HEIGHT);
        viewport.appendChild(renderer.domElement);

        // Create a camera, zoom it out from the model a bit, and add it to the scene.
        camera = new THREE.PerspectiveCamera(30, WIDTH / HEIGHT, 0.1, 10000);
        camera.lookAt(0, 0, 0);
        camera.position.set(1000, 1000, 200);
        scene.add(camera);

        // Create an event listener that resizes the renderer with the browser window.
        window.addEventListener('resize', function () {
            renderer.setSize(WIDTH, HEIGHT);
            camera.aspect = WIDTH / HEIGHT;
            camera.updateProjectionMatrix();
        });

        // Set the background color of the scene.
        renderer.setClearColorHex(0xffffff, 1);

        // Create a light, set its position, and add it to the scene.
        var light1 = new THREE.PointLight(0xaaaaaa);
        light1.position.set(-200, 300, -200);
        scene.add(light1);

        var light2 = new THREE.PointLight(0xffffff);
        light2.position.set(200, 300, 200);
        scene.add(light2);

        // Create the model and add it to the scene
        var model = createModel();
        model.position.set(0, 0, 0);
        scene.add(model);

        // Axis helper
        var axisHelper = new THREE.AxisHelper(500);
        scene.add(axisHelper);

        // Add OrbitControls so that we can pan around with the mouse.
        controls = new THREE.OrbitControls(camera, renderer.domElement);

        // Zoom to fit the object bounding box
//        zoomObject(camera, group);
    }

    /**
     * Renders the scene and updates the render as needed.
     * Read more about requestAnimationFrame at
     * http://www.paulirish.com/2011/requestanimationframe-for-smart-animating/
     */
    function animate() {
        requestAnimationFrame(animate);
        renderer.render(scene, camera);
        controls.update();
    }

    function collapse() {
        console.dir('Not implemented yet');
    }

    function createMesh(item) {
        var geom, material, texture;
        geom = new THREE.BoxGeometry(500, 500, item.thickness || 1);
        if (item.color) {
            material = new THREE.MeshLambertMaterial({
                color: item.color,
                transparent: true, // item.transparent || item.opacity < 1 ? true : false,
                opacity: item.opacity || 1.0
            });
        }
        if (item.material && item.material.texture) {
            texture = THREE.ImageUtils.loadTexture(item.material.texture);
            material = new THREE.MeshBasicMaterial({map: texture, side: THREE.DoubleSide});
        }
        return new THREE.Mesh(geom, material);
    }

    function createOriginMarker() {
        var marker = THREE.Object3D();
        var origin = new THREE.Vector3(0, 0, 0);
        [
            {dir: new THREE.Vector3(1, 0, 0), color: 0xff0000},
            {dir: new THREE.Vector3(0, 1, 0), color: 0x00ff00},
            {dir: new THREE.Vector3(0, 0, 1), color: 0x0000ff}
        ].forEach(function (axis) {
                    marker.add(new THREE.ArrowHelper(axis.dir, origin, 1, axis.color));
                });
        return marker;
    }

    function createModel() {
        var defaultElement = {
            name: "element",
            height: 500,
            width: 500,
            thickness: 10,
            color: 0xcccccc,
            opacity: 1.0,
            material: null,
            transparency: 1.0,
            type: "sheet",
            offset: [0, 0, 0, 0, 0, 0] // top, left, bottom, right, front, back
        };
        var subassembly = [],
                group = new THREE.Object3D(),
                mesh,
                thickness = 0,
                totalThickness = 0;
        model.forEach(function (element) {
            // TODO set default values for element
            if (Array.isArray(element)) {
                // get the thickest element in the list
                thickness = element.reduce(function (last, current) {
                    return (last < current.thickness) ? current.thickness : last;
                }, 0);
                // create a group to hold the sub-assembly
                mesh = new THREE.Object3D();
                // add elements to sub-assembly
                element.forEach(function (component) {
                    mesh.add(createMesh(component));
                });
                // TODO boolean operations
                group.add(subassembly);
            } else {
                thickness = element.thickness;
                mesh = createMesh(element);
            }
            mesh.position.set(0, 0, totalThickness + (thickness / 2));
            group.add(mesh);
            totalThickness += thickness || 0;
        });
        return group;
    }

    function explode() {
        console.dir('Not implemented yet');
    }

    function zoomObject(camera, obj) {
        var correctForDepth = 1.3;
        var rotationSpeed = 0.01;
        var scale = 1;
        // create an helper
        var helper = new THREE.BoundingBoxHelper(obj);
        helper.update();
        // get the bounding sphere
        var boundingSphere = helper.box.getBoundingSphere();
        // calculate the distance from the center of the sphere
        // and subtract the radius to get the real distance.
        var center = boundingSphere.center;
        var radius = boundingSphere.radius;
        var distance = center.distanceTo(camera.position) - radius;
        var realHeight = Math.abs(helper.box.max.y - helper.box.min.y);
        var fov = 2 * Math.atan(realHeight * correctForDepth / (10 * distance)) * (180 / Math.PI);
        camera.fov = fov;
        camera.updateProjectionMatrix();
    }

    // do it
    init();
    animate();
</script>

</body>
</html>